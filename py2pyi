# We use 2 Spaces for indents

import ast
import sys
from typing import Any
import inspect


def extract_stub(tree):
    """Extracts type hints, imports, comments, and docstrings into a .pyi file."""
    lines = extract_imports(tree)
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            extract_function_stub(node, lines)
        elif isinstance(node, ast.ClassDef):
            extract_class_stub(node, lines)
        elif isinstance(node, (ast.Assign, ast.AnnAssign)):
            extract_type_alias(node, lines)
        elif isinstance(node, ast.TypeAlias):
            extract_type_alias_statement(node, lines)
        elif isinstance(node, ast.Delete):
            extract_del_statement(node, lines)
    return "\n".join(lines)

def extract_imports(tree):
    """Extracts import statements from the original script."""
    imports = ["\n"]
    for node in tree.body:
        if isinstance(node, (ast.Import, ast.ImportFrom)):
            imports[0] = "# Imports"
            imports.append(ast.unparse(node)) # Convert AST back to code
    if not len(imports) == 1:
        imports.append("\n")
    return imports

def get_doc(node):
    return str(ast.get_docstring(node))

def extract_function_stub(node, lines, indent=""):
    """Extracts function signatures, docstrings, and comments."""
    arg_str = format_arguments(node.args, node.name)
    return_type = get_annotation(node.returns)
    if has_meaningful_docstring(node):
        lines.append(f'"""\n{get_doc(node)}\n"""')
    if is_overloaded_function(node):
        lines.append(f"{indent}@overload")
    method_type = detect_method_type(node)
    if method_type == "class":
        lines.append(f"{indent}@classmethod")
    elif method_type == "static":
        lines.append(f"{indent}@staticmethod")
    lines.append(f"{indent}def {node.name}({arg_str}) -> {return_type}: ...")

def extract_class_stub(node, lines):
    """Extracts class definitions, methods, docstrings, and comments."""
    base_classes = extract_base_classes(node)
    lines.append(f"class {node.name}{base_classes}:")
    if has_meaningful_docstring(node):
        lines.append(f'  """\n{str(ast.get_docstring(node, clean=False))}\n  """')
    method_lines = []
    has_methods = False
    for item in node.body:
        if isinstance(item, ast.FunctionDef):
            has_methods = True
            extract_function_stub(item, method_lines, indent="  ")
    if not has_methods and not has_meaningful_docstring(node):
        lines.append("  ...")
    else:
        lines.extend(method_lines)
    lines.append("")

def extract_del_statement(node, lines):
    """Handles `del` statements by marking names as deleted."""
    for target in node.targets:
        if isinstance(target, ast.Name):
            lines.append(f"del {target.id}")

def extract_type_alias(node, lines):
    """Handles type alias definitions like `Alias = SomeType` or `Alias: Type = ...`."""
    if isinstance(node, ast.AnnAssign) and isinstance(node.value, ast.Constant) and node.value.value is Ellipsis:
        alias_name = node.target.id
        alias_type = get_annotation(node.annotation)
        lines.append(f"{alias_name}: {alias_type} = ...")
    elif isinstance(node, ast.Assign) and len(node.targets) == 1:
        target = node.targets[0]
        if isinstance(target, ast.Name) and isinstance(node.value, ast.Constant) and node.value.value is Ellipsis:
            lines.append(f"{target.id}: Any = ...")
        elif isinstance(target, ast.Name):
            alias_type = get_annotation(node.value)
            lines.append(f"{target.id} = {alias_type}")

def extract_type_alias_statement(node, lines):
    """Handles `type NAME = OTHER_TYPE` statements correctly."""
    if isinstance(node, ast.TypeAlias):
        alias_name = node.name.id
        alias_type = get_annotation(node.value)
        lines.append(f"type {alias_name} = {alias_type}")

def extract_base_classes(node):
    """Extracts base classes of a class definition."""
    if not node.bases:
        return ""
    base_names = []
    for base in node.bases:
        if isinstance(base, ast.Name):
            base_names.append(base.id)
        elif isinstance(base, ast.Attribute):
            base_names.append(ast.unparse(base))
        elif isinstance(base, ast.Subscript):
            base_names.append(ast.unparse(base))
    return f"({', '.join(base_names)})"

def is_overloaded_function(node):
    """Checks if a function has multiple definitions (overloaded)."""
    return any(
        isinstance(decorator, ast.Name) and decorator.id == "overload"
        for decorator in node.decorator_list
    )

def has_meaningful_docstring(node):
    """Checks if a node has a meaningful docstring (not just `...`)."""
    if not node.body or not isinstance(node.body[0], ast.Expr) or not isinstance(node.body[0].value, ast.Constant):
        return False
    return str(node.body[0].value).strip() not in {"...", "Ellipsis"}

def detect_method_type(node):
    """Detects if a function is an instance, class, or static method."""
    for decorator in node.decorator_list:
        if isinstance(decorator, ast.Name):
            if decorator.id == "classmethod":
                return "class"
            elif decorator.id == "staticmethod":
                return "static"
    return "instance"

def format_arguments(args, function_name):
    """Formats function arguments with type hints, special markers, and fixes `self` handling."""
    params = []
    pos_only = [format_arg(arg) for arg in args.posonlyargs]
    if pos_only:
        params.extend(pos_only)
        params.append("/")
    params.extend(format_arg(arg) for arg in args.args)
    if args.vararg:
        params.append(f"*{args.vararg.arg}: Any")
    if args.kwonlyargs:
        params.append("*")
        params.extend(format_arg(arg) for arg in args.kwonlyargs)
    if args.kwarg:
        params.append(f"**{args.kwarg.arg}: Any")
    if function_name in {"__call__", "__init__"} and params and params[0].startswith("self: Any"):
        params[0] = "self"
    return ", ".join(params)

def format_arg(arg):
    """Formats a single function argument with its type annotation."""
    annotation = get_annotation(arg.annotation)
    return f"{arg.arg}: {annotation}"

def get_annotation(annotation):
    """Extracts annotation from AST node or defaults to Any."""
    if annotation is None:
        return "Any"
    if isinstance(annotation, ast.Name):
        return annotation.id
    if isinstance(annotation, ast.Subscript):
        base = get_annotation(annotation.value)
        subscript = get_annotation(annotation.slice)
        return f"{base}[{subscript}]"
    if isinstance(annotation, ast.Constant):
        return repr(annotation.value)
    return "Any"

def generate_pyi(file_path):
    """Generates a .pyi file for the given Python file."""
    with open(file_path, "r", encoding="utf-8") as f:
        tree = ast.parse(f.read())
    stub_content = extract_stub(tree)
    with open(file_path.replace(".py", ".pyi"), "w", encoding="utf-8", errors="strict") as f:
        f.write(stub_content)
    print(f"Stub file generated: {file_path.replace(".py", ".pyi")}")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        class Error(BaseException):
            """Base Error"""
        raise Error("Usage: python pyi-gen.py <python_file.py>")
    else:
        generate_pyi(sys.argv[1])
